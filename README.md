# <p width=600 align="center"><b>Using Jupyterlab with Python login and PostregSQL</b></p>


<p align="center">
<img align="center" src="img\jupyter-lab.svg" wodth=90%><br>
Diagram-1
</p>

In this post, we will build an authentication system for JupyterLab using PostgreSQL.
We will walk through configuring JupyterLab with a custom authentication method, where user credentials are securely stored in a PostgreSQL database.
To manage the system’s components, we will leverage Kubernetes, using Minikube to create and run the pods. Minikube runs locally on a laptop, providing a convenient single-node Kubernetes cluster for development and testing.

Diagram 1 illustrates the three main components of the system and how they connect to each other.

In this post, we will work with three main components:
 ### I.	PostgreSQL Database
 We deploy PostgreSQL in a dedicated pod. Since PostgreSQL persists its data on disk, we use a Persistent Volume Claim (PVC) to store the data files.
Using a PVC allows the data to be shared between PostgreSQL pods if we scale the pods up or down, ensuring data consistency.
The PostgreSQL pod also requires a Service and a Secret:
•	The Service (of type ClusterIP) provides internal access within the cluster. It allows the Flask authentication service to connect to PostgreSQL.
•	The Secret securely stores sensitive information, such as database credentials.

``` 
docker build -t postgresql:0.0.1 .
```


```
docker images
docker tag XXXX alaasalmo/postgresql:0.0.1
docker push alaasalmo/postgresql:0.0.1
```
```
kubectl create secret generic postgres-secret \
  --from-literal=POSTGRES_USER=admin \
  --from-literal=POSTGRES_PASSWORD=admin \
  --from-literal=POSTGRES_DB=jupyterlabdb \
  --from-literal=POSTGRES_PORT=5432
```

```
kubectl get pods
kubectl exec -it postgres-XXXXXXXXXX-XXXXX -- psql -U admin -d jupyterlabdb -c "CREATE TABLE users (id SERIAL PRIMARY KEY, username VARCHAR(50), password varchar(50));"
kubectl exec -it postgres-XXXXXXXXXX-XXXXX -- psql -U admin -d jupyterlabdb -c "\dt;"
kubectl exec -it postgres-XXXXXXXXXX-XXXXX -- psql -U admin -d jupyterlabdb -c "insert into users (username,password) values ('username','password');"
kubectl exec -it postgres-XXXXXXXXXX-XXXXX -- psql -U admin -d jupyterlabdb -c "select * from users;"
```
```
kubectl apply -f pvc.yaml
kubectl apply -f postgresql-service.yaml
kubectl apply -f postgresql-deployment.yaml
```

Files: <a href="postgresql/">postgresql</a>

 ### II. Jupyter Lab server

We deploy the JupyterLab server in its own pod. This pod requires a ConfigMap and a Service:

The ConfigMap contains configuration details like:

Minikube server IP address
Session duration (in minutes)
External port number

These configurations are used by both the authentication system and the JupyterLab server to manage session lifetimes and network settings.
The Service (of type NodePort) exposes JupyterLab externally after the user successfully authenticates.
Accessing JupyterLab requires a token. Without a valid token, JupyterLab denies access. Each time the JupyterLab server starts, it generates a new token using the following command:

```export JUPYTER_TOKEN=$(python3 -c 'import uuid; print(uuid.uuid4())')```

This token is later used by the authentication system to forward users to JupyterLab after successful login.

```
docker build -t jupyterlab:1.0.8 .
```
```
docker images
docker tag XXXXX alaasalmo/jupyterlab:1.0.8
docker push
```
```
kubectl apply -f pvc.yaml
```
```
cat <<EOF > jupyter-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: jupyter-config
data:
  JUPYTERPORT: "30088" 
  SESSION: "15" 
  MINIKUBE_IP: "$(minikube ip)"
EOF
```

```
kubectl apply -f jupyter-configmap.yaml
kubectl apply -f jupyterlab-service.yaml
kubectl apply -f jupyter-deployment.yaml
```

Files: <a href="jupyterlab/">jupyterlab</a>

 ### III. Flask authentication

This pod handles user authentication by requesting a username and password. After successful login, it uses the token generated by the JupyterLab server to forward users to JupyterLab. To enable this, the JupyterLab and Flask pods must share the same path for the token, allowing JupyterLab to create it and Flask to read it for secure redirection.

<p align="center">
<img align="center" src="img\details.drawio.svg" wodth=90%><br>
Diagram-2
</p>

Diagram 2 illustrates how the two components — JupyterLab and the Python Flask application — share a Persistent Volume Claim (PVC) mounted at /notebook.
When the JupyterLab server starts, it generates an authentication token and stores it in the shared PVC.
The Flask application then reads this token to authenticate users and redirect them to the JupyterLab interface.

The session timeout value is retrieved from the jupyter-config ConfigMap, using the SESSION variable, which specifies the session duration in minutes.

```
docker build -t flaskauth:0.0.2 .
```
```
docker images
docker tag XXXXX alaasalmo/flaskauth:0.0.2
docker push alaasalmo/flaskauth:0.0.2
```

```
kubect lapply -f jupyter-configmap.yaml
kubectl apply -f flask-deployment.yaml
kubectl apply -f flask-service.yaml
```
Files: <a href="pythonlogin/">pythonlogin</a>
